\documentclass[12pt]{scrartcl}
\usepackage{fixltx2e} % LaTeX patches, \textsubscript
\usepackage{cmap} % fix search and cut-and-paste in Acrobat
\usepackage{ifthen}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\setcounter{secnumdepth}{0}
\usepackage{tabularx}

%%% Custom LaTeX preamble
% serif headings:
\addtokomafont{disposition}{\rmfamily}
\addtokomafont{descriptionlabel}{\rmfamily}
% hyperlinks:
\ifthenelse{\isundefined{\hypersetup}}{
  \usepackage[colorlinks=true,linkcolor=blue,urlcolor=blue]{hyperref}
  \urlstyle{same} % normal text font (alternatives: tt, rm, sf)
}{}
\hypersetup{
  pdftitle={Extending Raft with Structured Voting},
}

%%% Title Data
\title{Extending Raft with Structured Voting}
\author{Leonhard Markert (lm510) \\ Emmanuel College}
\date{}

%%% Body
\begin{document}
\maketitle

% Docinfo
\begin{center}
\begin{tabularx}{350pt}{rX}
\textbf{Project Supervisors} & Malte Schwarzkopf and Ionel Gog \\
\textbf{Director of Studies} & Dr Jonathan Hayman \\
\textbf{Overseers} & Dr Markus Kuhn and Dr Neal Lathia \\
\end{tabularx}
\end{center}

\newpage

\section{Introduction and Description of Work%
  \label{introduction-and-description-of-work}%
}

Finding a consensus is a key functionality of any strongly consistent distributed system. Raft \cite{raft} is a new consensus algorithm that is designed to be used instead of Paxos \cite{paxos} whilst being easier to understand and implement correctly. It models the distributed system as a replicated state machine using a replicated log. Raft features a strong leader, an explicit membership change mechanism and a (partial) correctness proof.\footnote{Safety Proof and Formal Specification for Raft, accessed October 17, 2013. \url{http://raftuserstudy.s3-website-us-west-1.amazonaws.com/proof.pdf}}

By default, Raft uses majority voting to find quorums. Both the initial paper and the separate correctness proof suggest that it should be possible to replace majority voting by other voting schemes.

Structured voting schemes \cite{voting} impose a logical structure on the set of processes and use structural properties to specify quorum systems. Each voting scheme defines a way to construct \emph{write quorums}, with the property that any two write quorums overlap. The Grid protocol, for instance, logically arranges all nodes in a rectangular grid. A write quorum in the Grid protocol consists of the union of one entire row of nodes and one entire column of nodes. Clearly, any two such write quorums intersect. Since this intersection property is the only requirement for the correctness proof, replacing majority consensus by a write quorum computed from a structured voting scheme does not affect the correctness of the Raft algorithm.

Structured voting protocols have the drawback that they may fail to generate a quorum even though more than half of the nodes are available (i.\,e.\ neither failed nor busy). They may, on the other hand, find a quorum even when fewer than half of the nodes are available. Majority voting will always succeed in finding a quorum in the former case, and it will necessarily fail to do so in the latter case. Thus structured voting schemes allow for a trade-off, being less reliable than majority voting if most nodes are available, but more reliable if the majority of nodes is not available.

There are at least two scenarios under which this last point becomes relevant: Firstly, under high load, a majority of nodes may be busy processing requests. Using a structured voting scheme, it may still be possible to get a quorum, avoiding an expensive retry of the operation that would be necessary when a majority voting scheme was employed. Secondly, it may be that node failures are not, as is often assumed, independent. In this case, the structured voting scheme could be specifically designed for resilience against certain failure modes like the power outage of entire racks or connection problems between data centres.

The aim of this project is twofold: To add structured voting protocols to an existing implementation of the Raft consensus algorithm, and to compare the performance of different structured voting protocols with the performance of Raft's default majority consensus voting.


\section{Starting Point%
  \label{starting-point}%
}
%

In this project, I will extend an existing implementation of the Raft consensus algorithm that is written in Erlang. Here is an overview of my prior knowledge and experience with the concepts and tools I will use to complete the project:

\begin{description}

\item[Raft consensus algorithm.] I have listened to a recorded lecture on Raft by one of its creators. I have skimmed through the relevant sections of the paper and the separate correctness proof.

\item[Implementation of Raft.] \emph{Rafter}\footnote{Andrew J.\,Stone. Rafter: An Erlang library application which implements the Raft consensus protocol (Git repository), accessed October 17, 2013. \url{https://github.com/andrewjstone/rafter}} is an open source implementation of Raft written in Erlang by Andrew J.\,Stone at Basho, Inc. It still being developed, but mostly feature-complete. I will use its code as the basis for this project.

\item[Concurrent and Distributed Systems.] The Part IB lecture courses Concurrent Systems and Distributed Systems have given me an appreciation for the challenges that such systems pose. During my work placement this summer, I implemented a minimalistic distributed key-value store that used structured voting protocols to guarantee consistency as a proof of concept in Node.js/JavaScript.

\item[Erlang programming language.] Most of the code I will be writing for this project will be in Erlang, a programming language I have no prior experience with. However, I am familiar with functional programming from both the Part IA Standard ML exercises and from small personal projects in Haskell and OCaml.

\end{description}


\section{Substance and Structure of the Project%
  \label{substance-and-structure-of-the-project}%
}

The objective of this project is to add structured voting protocols to Rafter, and to benchmark different structured voting protocols against each other and against Raft's default majority consensus algorithm.

All the unstructured and structured voting schemes that will be implemented can be specified by voting structures \cite{voting}, which describe the set of quorums. For each voting scheme, a generator will have to be written that maps the set of nodes and potentially some further options to a voting structure. We will also require an interpreter algorithm that decides whether a certain set of nodes constitutes a quorum within a given voting structure.

In order for Rafter to use voting schemes for quorum finding, the data structure which specifies a node's configuration will have to include the current voting structure.

For benchmarking purposes, an application on top of Rafter will be required. A simple in-memory key-value store has already been implemented. Several optional extensions to this key-value store are possible.

\section{Success Criteria%
  \label{success-criteria}%
}

For the project to be deemed a success the following items must be successfully completed:

\begin{enumerate}

\item Design of the data structure to represent voting structures and implementation and testing of the algorithm to interpret it. Implementation and testing of voting structure generators for at least Majority Voting and the Grid Protocol. In order to allow for visual verification of the voting structure generators, I will write a tool that can output a diagrammatic representation of a voting structure.

\item Incorporating the above algorithms and data structures into Rafter so they can be used to find quorums.

\item Design and implementation of a benchmark suite for a distributed key-value store on top of Rafter.

\item The project must be set up so it can be run as a distributed key-value store in the Amazon Elastic Compute Cloud (EC2) infrastructure. Then the benchmarks have to be run and the results collected and evaluated.

\item The dissertation must be planned and written.

\end{enumerate}

\section{Optional Extensions%
  \label{optional-extensions}%
}
%
\begin{itemize}

\item Heterogeneous voting scheme configuration

\item Advanced key-value store: Queries, transactions

\item Profiling and performance tuning

\item Universal voting structure generator

\end{itemize}


\section{Timetable and Milestones%
  \label{timetable-and-milestones}%
}


\subsection{Before Proposals Submission%
  \label{before-proposals-submission}%
}

Discussion with Overseers and Director of Studies. Allocation of and discussion with Project Supervisor, preliminary reading, writing Project Proposal. Discussion with Supervisor to arrange a schedule of regular meetings for obtaining support during the course of the year.

Milestones: Phase 1 Report Form on Monday 14, 2013, then a Project Proposal complete with as realistic a timetable as possible by Wednesday 17, 2013, approval from Overseers and confirmed availability of any special resources needed. Signatures from Supervisor and Director of Studies.


\subsection{Weeks 1 and 2 (Oct 21 to Nov 3)%
  \label{weeks-1-and-2-oct-21-to-nov-3}%
}

Familiarisation with Erlang: I will read the relevant parts of the introductory Erlang book \emph{Learn You Some Erlang for Great Good} \cite{lysefgg}, get an overview over the Erlang documentation, and write small example programs in Erlang.


\subsection{Weeks 3 to 6 (Nov 3 to Dec 1)%
  \label{weeks-3-to-6-nov-3-to-dec-1}%
}

Designing the voting structure data representation and implement generators for majority consensus, the grid and the tree quorum protocol as well as an algorithm to interpret voting structures. For debugging, I will write a tool that allows a visual representation of the generated voting structures.


\subsection{Weeks 7 and 8 (Dec 2 to Dec 15)%
  \label{weeks-7-and-8-dec-2-to-dec-15}%
}

Incorporate voting structures into Rafter.


\subsection{Weeks 9 to 11 (Dec 16 to Jan 5)%
  \label{weeks-9-to-11-dec-16-to-jan-5}%
}

Christmas break.


\subsection{Week 12 (Jan 6 to Jan 12)%
  \label{week-12-jan-6-to-jan-12}%
}

Finish incorporating voting structures into Rafter and testing.


\subsection{Weeks 13 and 14 (Jan 13 to Jan 26)%
  \label{weeks-13-and-14-jan-13-to-jan-26}%
}

Write progress report and create presentation


\subsection{Weeks 15 and 16 (Jan 27 to Feb 9)%
  \label{weeks-15-and-16-jan-27-to-feb-9}%
}

Design and write benchmarking suite.


\subsection{Weeks 17 and 18 (Feb 10 to Feb 23)%
  \label{weeks-17-and-18-feb-10-to-feb-23}%
}

Set-up and configuration for Amazon EC2. Benchmarking.


\subsection{Weeks 19 and 20 (Feb 24 to Mar 9)%
  \label{weeks-19-and-20-feb-24-to-mar-9}%
}

Time for extensions / buffer.


\subsection{Weeks 21 to 25 (Mar 10 to Apr 13)%
  \label{weeks-21-to-25-mar-10-to-apr-13}%
}

Write Dissertation.


\subsection{Weeks 24 to 26 (Apr 14 to Apr 27)%
  \label{weeks-24-to-26-apr-14-to-apr-27}%
}

Clean-up of code and dissertation.


\section{Resources Required%
  \label{resources-required}%
}
%
Development will predominantly be on my laptop running Linux. I accept full responsibility for this machine and I have made contingency plans to protect myself against hardware and/or software failure: I will use Git to keep track of changes in my code and reports, and I will push these changes to my GitHub repository\footnote{\href{http://github.com}{GitHub} is a Git repository hosting service. The most current version of my code and reports will be available at \url{http://github.com/curiousleo/rafter}}  every day. In addition, I will take weekly backups to an external hard drive.

In order to benchmark the project under realistic conditions, I will require Amazon EC2 compute time on a sufficient number of nodes (at least 100). My supervisors have assured me that the Systems Research Group has credits available that I can use.

\bibliographystyle{plain}
\bibliography{Bibliography}

\end{document}
